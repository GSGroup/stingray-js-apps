ReversiDisc : Rectangle {
	radius: 15;
	height: 50;
	borderWidth: 2;
	Behavior on width { animation: Animation { duration: 200; } }
}

ReversiCell : Rectangle {
	id: cellItem;
	property enum { Empty, Black, White } disc: Empty;

	width: 65;
	height: 65;

	color: "#151";
	borderColor: "#432100";
	borderWidth: 1;

	ReversiDisc {
		id: white;
		color: "#fff";
		borderColor: "#000";
		anchors.centerIn: parent;
		width: cellItem.disc == ReversiCell::Disc::White? 50: 0;
	}

	ReversiDisc {
		id: black;
		color: "#000";
		borderColor: "#fff";
		anchors.centerIn: parent;
		width: cellItem.disc == ReversiCell::Disc::Black? 50: 0;
	}
}

ReversiBoard : Grid {
	id: boardItem;

	columns: 8;
	rows: 8;
	width: childrenWidth;
	height: childrenHeight;
	focus: true;

	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}
	ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {} ReversiCell {}

	property int cursorX: 3;
	property int cursorY: 3;
	property bool playerWhite: true;
	property int difficultyLevel: 0;

	Rectangle {
		id: cursor;
		color: "#0000";
		borderWidth: 6;
		borderColor: boardItem.playerWhite? "#fff": "#000";
		radius: 5;

		width: 65;
		height: 65;
		x: boardItem.cursorX * 65;
		y: boardItem.cursorY * 65;

		Behavior on x { animation: Animation { duration: 200; } }
		Behavior on y { animation: Animation { duration: 200; } }
	}

	onUpPressed: {
		if (cursorY > 0) --cursorY;
	}

	onDownPressed: {
		if (cursorY < 7) ++cursorY;
	}

	onLeftPressed: {
		if (cursorX > 0) --cursorX;
	}

	onRightPressed: {
		if (cursorX < 7) ++cursorX;
	}

	native {
		ReversiCell *Get(int y, int x) const { int idx = y * 8 + x; return argile_cast<ReversiCell *>(children.at(idx)); }
		int MakeMove(int y, int x, bool white, bool simulate) const;
		int GetPositionalBonus(int y, int x, bool white);

		struct State {
			int state[8][8];
		};

		void Save(State &state);
		void Restore(State &state);

		void Reset() {
			for(int i = 0; i < 8; ++i) for(int j = 0; j < 8; ++j) {
				ReversiCell *cell = Get(i, j);
				if ((i == 3 && j == 3) || (i == 4 && j == 4))
					cell->disc = ReversiCell::Disc::White;
				else if ((i == 3 && j == 4) || (i == 4 && j == 3))
					cell->disc = ReversiCell::Disc::Black;
				else
					cell->disc = ReversiCell::Disc::Empty;
			}
			cursorX = 3;
			cursorY = 3;
		}

		bool NextMove(bool white, bool simulate);

	}
}

Reversi : Application {
	id: reversiItem;
	name: "reversi";
	displayName: l"Reversi";

	property bool gameOver: false;

	BigText {
		id: titleText;
		text: l"Reversi";
		anchors.top: parent.top;
		anchors.horizontalCenter: parent.horizontalCenter;
	}

	ReversiBoard {
		id: board;
		anchors.centerIn: parent;
	}

	Row {
		anchors.left: board.left;
		anchors.bottom: board.top;
		spacing: 10;

		MainText {
			text: l"White";
		}

		MainText {
			id: whiteCounter;
			text: "2";
		}
	}

	Row {
		anchors.right: board.right;
		anchors.bottom: board.top;
		spacing: 10;

		width: childrenWidth;
		height: childrenHeight;

		MainText {
			id: blackCounter;
			text: "2";
		}

		MainText {
			text: l"Black";
		}
	}

	BigText {
		id: gameOver;
		Rectangle {
			anchors.fill: parent;
			anchors.margins: -20;
			color: "#000c";
		}
		anchors.centerIn: parent;
		visible: reversiItem.gameOver;
		style: Style.Shadow;
		styleColor: "#333";
	}

	native {
		bool UpdateStats();
		void Reset() {
			Local()->board->Reset();
			gameOver = false;
		}
	}

	Timer {
		id: aiMoveTimer;
		interval: 500;
		onTriggered: {
			board->NextMove(!board->playerWhite, false); //my move
			
			if (!board->NextMove(board->playerWhite, true)) //no next move for player
			{
				if (!board->NextMove(!board->playerWhite, true)) //no next move for ai also, game over
				{
					bool whiteIsWinner = reversiItem->UpdateStats();					
					if(whiteIsWinner)
						gameOver->text = board->playerWhite ? self->tr("You won!") : self->tr("Game Over");
					else gameOver->text = !board->playerWhite ? self->tr("You won!") : self->tr("Game Over");
					reversiItem->gameOver = true;
				}
				else
					self->Restart(); //one more time
			}
			reversiItem->UpdateStats();
		}
	}

	onBackPressed: {
		viewsFinder->closeApp();
	}

	onKeyPressed: {
		if(visible) {
			if (gameOver) {
				gameOver = false;
				Reset();
				return true;
			}
			BaseContext::Log.Info() << "key: " << key;
			if (key == "Select") {
				if (aiMoveTimer->running) //ai is "thinking"
					return true;

				BaseContext::Log.Info() << "player moves into " << board->cursorY << ", " << board->cursorX;
				if (board->MakeMove(board->cursorY, board->cursorX, board->playerWhite, false) <= 0)
					return true;

				reversiItem->UpdateStats();
				aiMoveTimer->Start();
				return true;
			} else if (Local()->contextMenu->processKey(key))
				return true;
		}
		return false;
	}

	ContextMenu {
		id: contextMenu;
		anchors.fill: parent;
		onItemChoosed: {
			switch (index) {
			case ContextMenu::RedButton:
				if (aiMoveTimer->running) //ai is "thinking"
					return;
				board->NextMove(board->playerWhite, false);
				reversiItem->UpdateStats();
				aiMoveTimer->Start();
				break;
			case ContextMenu::GreenButton:
				board->playerWhite = true;
				reversiItem->Reset();
				reversiItem->UpdateStats();
				break;
			case ContextMenu::YellowButton:
				board->playerWhite = false;
				reversiItem->Reset();
				reversiItem->UpdateStats();
				break;
			case ContextMenu::BlueButton:
				int d = board->difficultyLevel + 1;
				if (d > 1) //0..1 for now
					d = 0;

				BaseContext::Log.Info() << "changing difficulty to " << d;
				ZapperSettings::Get()->Write("reversiDifficultyLevel", d);

				board->difficultyLevel = d;
				reversiItem->updateDifficultyLevel();
				break;
			}
		}
	}

	updateDifficultyLevel: {
		switch(board->difficultyLevel.Ref()) {
		case 0: contextMenu->setMenuItemText(3, tr("Easy")); break;
		case 1: contextMenu->setMenuItemText(3, tr("Hard")); break;
		}
	}

	onVisibleChanged: {
		ContextMenu::ContextMenuItemVector items;
		items.reserve(4);
		items.push_back(self->tr("Help"));
		items.push_back(self->tr("Start with white"));
		items.push_back(self->tr("Start with black"));
		items.push_back(std::string());
		contextMenu->setItems(items);
		self->updateDifficultyLevel();
	}

	onCompleted: {
		board->Reset();
		board->difficultyLevel = ZapperSettings::Get()->Read<int>("reversiDifficultyLevel");
	}
}
