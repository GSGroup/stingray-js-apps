import "ReversiDisc.qml";
import "ReversiCell.qml";
import "ReversiBoard.qml";

Application {
	id: reversiItem;
	name: "reversi";
	displayName: l"Reversi";

	property bool gameOver: false;

	BigText {
		id: titleText;
		text: l"Reversi";
		anchors.top: parent.top;
		anchors.horizontalCenter: parent.horizontalCenter;
	}

	ReversiBoard {
		id: board;
		anchors.centerIn: parent;
	}

	Row {
		anchors.left: board.left;
		anchors.bottom: board.top;
		spacing: 10;

		MainText {
			text: l"White";
		}

		MainText {
			id: whiteCounter;
			text: "2";
		}
	}

	Row {
		anchors.right: board.right;
		anchors.bottom: board.top;
		spacing: 10;

		width: childrenWidth;
		height: childrenHeight;

		MainText {
			id: blackCounter;
			text: "2";
		}

		MainText {
			text: l"Black";
		}
	}

	BigText {
		id: gameOver;
		Rectangle {
			anchors.fill: parent;
			anchors.margins: -20;
			color: "#000c";
		}
		anchors.centerIn: parent;
		visible: reversiItem.gameOver;
		style: Style.Shadow;
		styleColor: "#333";
	}

	native {
		bool UpdateStats();
		void Reset() {
			Local()->board->Reset();
			gameOver = false;
		}
	}

	Timer {
		id: aiMoveTimer;
		interval: 500;
		onTriggered: {
			board->NextMove(!board->playerWhite, false); //my move
			
			if (!board->NextMove(board->playerWhite, true)) //no next move for player
			{
				if (!board->NextMove(!board->playerWhite, true)) //no next move for ai also, game over
				{
					bool whiteIsWinner = reversiItem->UpdateStats();					
					if(whiteIsWinner)
						gameOver->text = board->playerWhite ? self->tr("You won!") : self->tr("Game Over");
					else gameOver->text = !board->playerWhite ? self->tr("You won!") : self->tr("Game Over");
					reversiItem->gameOver = true;
				}
				else
					self->Restart(); //one more time
			}
			reversiItem->UpdateStats();
		}
	}

	onBackPressed: {
		viewsFinder->closeApp();
	}

	onKeyPressed: {
		if(visible) {
			if (gameOver) {
				gameOver = false;
				Reset();
				return true;
			}
			BaseContext::Log.Info() << "key: " << key;
			if (key == "Select") {
				if (aiMoveTimer->running) //ai is "thinking"
					return true;

				BaseContext::Log.Info() << "player moves into " << board->cursorY << ", " << board->cursorX;
				if (board->MakeMove(board->cursorY, board->cursorX, board->playerWhite, false) <= 0)
					return true;

				reversiItem->UpdateStats();
				aiMoveTimer->Start();
				return true;
			} else if (Local()->contextMenu->processKey(key))
				return true;
		}
		return false;
	}

	ContextMenu {
		id: contextMenu;
		anchors.fill: parent;
		onItemChoosed: {
			switch (index) {
			case ContextMenu::RedButton:
				if (aiMoveTimer->running) //ai is "thinking"
					return;
				board->NextMove(board->playerWhite, false);
				reversiItem->UpdateStats();
				aiMoveTimer->Start();
				break;
			case ContextMenu::GreenButton:
				board->playerWhite = true;
				reversiItem->Reset();
				reversiItem->UpdateStats();
				break;
			case ContextMenu::YellowButton:
				board->playerWhite = false;
				reversiItem->Reset();
				reversiItem->UpdateStats();
				break;
			case ContextMenu::BlueButton:
				int d = board->difficultyLevel + 1;
				if (d > 1) //0..1 for now
					d = 0;

				BaseContext::Log.Info() << "changing difficulty to " << d;
				ZapperSettings::Get()->Write("reversiDifficultyLevel", d);

				board->difficultyLevel = d;
				reversiItem->updateDifficultyLevel();
				break;
			}
		}
	}

	updateDifficultyLevel: {
		switch(board->difficultyLevel.Ref()) {
		case 0: contextMenu->setMenuItemText(3, tr("Easy")); break;
		case 1: contextMenu->setMenuItemText(3, tr("Hard")); break;
		}
	}

	onVisibleChanged: {
		ContextMenu::ContextMenuItemVector items;
		items.reserve(4);
		items.push_back(self->tr("Help"));
		items.push_back(self->tr("Start with white"));
		items.push_back(self->tr("Start with black"));
		items.push_back(std::string());
		contextMenu->setItems(items);
		self->updateDifficultyLevel();
	}

	onCompleted: {
		board->Reset();
		board->difficultyLevel = ZapperSettings::Get()->Read<int>("reversiDifficultyLevel");
	}
}
